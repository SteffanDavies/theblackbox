[{"content":"Introduction The pytube library for Python3 is a popular toolbox for accessing YouTube content. One of it\u0026rsquo;s main quirks is that it does not rely on any third-party dependencies, while providing a number of simple tools for querying and downloading videos, audio-tracks and captions.\nWhile pytube has proven to be a useful library for many people (as of writing it has over 2k forks and 9.7k stars on GitHub), some recent changes at YouTube have left it largely broken.\nTo make things worse, the project seems to be all but abandoned by it\u0026rsquo;s maintainers, despite still having an active (and desperate) community sharing their frustrations in the Issues tab of the repository, and providing each other with workarounds. The documentation is also outdated, asking the user to use deprecated functions in the tutorial.\nDue to the growing discontent with the repositories\u0026rsquo; stagnation, part of the community forked the repo to create pytubefix, which solves a number of issues. Perhaps the maintainers of pytubefix expect their fork to eventually be merged back into the original pytube repo, but I\u0026rsquo;m skeptical this will happen soon.\nFor this reason, the examples listed in the article will use the pytubefix library as it is identical to pytube.\nInstalation To start, we will be using a clean conda environment and install Python 3.12 and Jupyter Lab as our coding environment.\nConda is a popular package management solution for Python as it allows the user to easily create independent environments containing their own packages, avoiding conflicts between project dependencies. A guide for installing on Linux can be found here.\nOnce we have installed conda, we can create a new environment and install Jupyter Lab from the conda-forge channel. We will then add our python kernel from this conda environment to Jupyter.\n1 2 3 4 conda create -n pytube conda activate pytube conda install -c conda-forge jupyterlab ipython kernel install --user --name=pytube Jupyter Lab is part of Project Jupyter and allows for the creation of interactive coding projects. Now that is installed we will create a folder for our project and launch Jupyter Lab:\n1 2 3 mkdir pytube cd pytube jupyter lab Now you should have a Jupyter Server running and your default browser should open in the corresponding localhost address. If not, check your console output for the link.\nIn the Jupyter interface launcher tab, under the Notebook section, click on pytube to launch a new Jupyter Notebook.\nInstall and import libraries Now that we have our Jupyter Notebook running, we should install pytube and import all our libraries for the project. Let\u0026rsquo;s start by installing pytubefix.\n1 2 import sys !{sys.executable} -m pip install pytubefix Notice how we use the ! before running our command. This instructs IPython to run a shell command instead of python code. {sys.executable} is our Python 3.12 kernel from the pytube conda environment. Installing directly to a python or python3 keyword runs the risk of summoning our base python kernel instead, which we don\u0026rsquo;t want.\nLet\u0026rsquo;s go ahead and import the libraries:\n1 2 from pytubefix import YouTube, Playlist, Channel, Search from IPython.display import Image, Video, Audio In case you are wondering, the IPython.display module provides Image and Video classes for visualizing each of these types of media within our Jupyter Notebook.\nThumbnails Retrieving video thumbnails is easy in pytube. We start by instantiating a YouTube object using the video URL. This object will contain a number of properties such as the video title:\n1 2 yt = YouTube(\u0026#39;http://youtube.com/watch?v=2lAe1cqCOXo\u0026#39;) yt.title The thumbnail can be presented using a single line of code, by leveraging the Ipython image class. Here we pass the thumbnail URL of the YouTube object and set an acceptable width:\n1 Image(url=yt.thumbnail_url, width=512) Videos Obtaining video info We can work with a video by instantiating a Youtube object while passing the video url. Here we will instantiate the object and access it\u0026rsquo;s properties:\n1 2 3 4 5 6 7 8 9 10 11 video = YouTube(\u0026#39;http://youtube.com/watch?v=2lAe1cqCOXo\u0026#39;) title = video.title views = video.views url = video.watch_url print(f\u0026#34;{video.title} - {video.watch_url} ({video.views:,} views)\\n\u0026#34;) print(f\u0026#34;Author:\\t{video.author}\u0026#34;) print(f\u0026#34;Date:\\t{video.publish_date}\u0026#34;) print(f\u0026#34;\\nDescription:\\n{video.description}\u0026#34;) Gathering streams When downloading, you have to choose between DASH (adaptive) and Progressive content streams for video, and an audio-only stream.\nDASH: Highest quality. However, audio and video are separate and must be joined using FFmpeg or another tool. Progressive: Not as high quality. This is the \u0026ldquo;old\u0026rdquo; way of Youtube providing content. Audio and Video are together in the same file. To make things simple, we will use the progressive stream as an example:\n1 2 3 4 5 6 7 8 9 10 adaptive_streams = video.streams.filter(adaptive=True) progressive_streams = video.streams.filter(progressive=True) print(\u0026#34;Adaptive streams (DASH):\\n\u0026#34;) for stream in adaptive_streams: print(stream) print(\u0026#34;\\n\\nProgressive streams:\\n\u0026#34;) for stream in progressive_streams: print(stream) In this case, there is a 360p and a 720p progressive stream available. We can obtain some metadata from the 360p stream properties:\n1 2 3 4 5 6 stream = video.streams.get_by_itag(18) print(f\u0026#34;Title:\\t\\t{stream.title}\u0026#34;) print(f\u0026#34;Filename:\\t{stream.default_filename}\u0026#34;) print(f\u0026#34;Bitrate:\\t{stream.bitrate}\u0026#34;) print(f\u0026#34;Filesize:\\t{stream.filesize_mb} MB\u0026#34;) Downloading a video Let\u0026rsquo;s download the 360p version:\n1 stream.download(output_path=\u0026#34;./downloads/\u0026#34;, filename=\u0026#34;360p.mp4\u0026#34;, filename_prefix=\u0026#34;test_\u0026#34;) One of the reasons why working in Jupyter is so great, at least for prototyping, is because we can view our work immediately:\n1 Video(\u0026#34;./downloads/test_360p.mp4\u0026#34;, width=512) Retrieving Captions Downloading Captions Grabbing the media captions is just as easy. All we have to do is filter the captions property of our Youtbe object by language code (it\u0026rsquo;s a dictionary-like object), and then call then use the save_captions function to write the result to a file (note that they are in .srt style).\n1 video.captions[\u0026#34;en\u0026#34;].save_captions(\u0026#34;captions_en.srt\u0026#34;) Listing All Languages If you are not interested in English captions, you can list the available languages by using the caption_tracks property:\n1 video.caption_tracks Playlists Getting Playlist Data It\u0026rsquo;s also possible to retrieve Playlists and their contents using pytube. Let\u0026rsquo;s go ahead and see some of the information we can print out:\n1 2 3 4 5 6 7 8 9 playlist = Playlist(\u0026#39;https://www.youtube.com/playlist?list=PLzH6n4zXuckoUWpzSEpQNW6I8rXIzyi8w\u0026#39;) print(f\u0026#34;\\ Playlist title:\\t\\t{playlist.title}\\n\\ View count:\\t\\t{playlist.views:,}\\n\\ Playlist owner:\\t\\t{playlist.owner}\\n\\ Video count:\\t\\t{playlist.length:,}\\n\\ \\n{playlist.description}\\n\\ \u0026#34;) Playlist title:\tPong, Python \u0026amp; Pygame\nView count:\t29,058\nPlaylist owner:\tComputerphile\nVideo count:\t4\nSquash-Pong created in python by Dr Isaac Triguero\nListing Playlist Videos As we can see, useful information is stored in the Playlist object\u0026rsquo;s properties. From here, we can create separate lists of all the videos, titles and URLs and zip them up into a tuple:\n1 2 3 4 5 6 7 8 titles = [video.title for video in playlist.videos] views = [video.views for video in playlist.videos] urls = playlist.video_urls videos = list(zip(titles, urls, views)) for video in videos: print(f\u0026#34;{video[0]} - {video[1]} ({video[2]:,} views)\u0026#34;) Pong, Python \u0026amp; Pygame 00 - Computerphile - https://www.youtube.com/watch?v=JRLdbt7vK-E (89,593 views)\nPong, Python \u0026amp; PyGame 01 - Computerphile - https://www.youtube.com/watch?v=hHtb-Ohyfu8 (60,029 views)\nPong, Python \u0026amp; Pygame 10 - Computerphile - https://www.youtube.com/watch?v=Nk3Och0I4ZY (37,610 views)\nPong, Python \u0026amp; PyGame 11 - Computerphile - https://www.youtube.com/watch?v=VyrAVNoEf0g (36,951 views)\nâ€” Output\nDownloading Video playlists Finally, we can download the playlist contents using the download function. In this case, we will retrieve the video streams with the highest quality possible:\n1 2 for video in playlist.videos: video.streams.get_highest_resolution().download(output_path=\u0026#34;./downloads/\u0026#34;) Downloading Audio If we are only interested in the audio, we can fetch the audio track separately:\n1 2 for video in playlist.videos: video.streams.get_audio_only().download(mp3=True, output_path=\u0026#34;./downloads/\u0026#34;) Now let\u0026rsquo;s listen:\n1 Audio(\u0026#34;downloads/Pong, Python \u0026amp; Pygame 00 - Computerphile.mp3\u0026#34;) Channels Listing Content If we are looking for more than just a playlist, and need all the content from a channel, this is also possible:\n1 2 channel = Channel(\u0026#34;https://www.youtube.com/@Computerphile/\u0026#34;) channel.channel_name Considering this is a large channel, let\u0026rsquo;s list the names of the first 5 videos in 2021:\n1 2 for vid in channel.videos[:5]: print(vid.title) Filtering We could even filter videos of a channel based on, for example, the day, month or year they were published, as pytube provides datetime properties for the videos. Note that sequentially iterating all the videos of a channel is an extremely slow process.\n1 2 videos = [video for video in channel.videos if video.publish_date.year==2022 if video.publish_date.month==11] titles = [video.title for video in videos] Searching Searching YouTube Pytube also contains a search functionality.\n1 2 3 4 5 6 search = Search(\u0026#34;Harvard CS50\u0026#34;) print(f\u0026#34;\u0026#34;\u0026#34;Results for {search.query} query:\\n\u0026#34;\u0026#34;\u0026#34;) for result in search.results: print(result.title) The search results are limited to avoid infinite loops. We can get more results using the get_next_results function, which will append more results to the results property.\n1 2 3 search.get_next_results() for result in search.results(): print(result.title) Completion suggestions Search completion suggestions can also be obtained using the completion_suggestions property:\n1 search.completion_suggestions Conclusion Pytube is a cute little library for searching and downloading YouTube content. It\u0026rsquo;s incredibly simple and easy to use. However, it\u0026rsquo;s current state is almost unusable due to internal changes at YouTube breaking the code. In the meantime, pytubefix is recommended until issues are resolved.\n","date":"2023-12-18T00:00:00Z","image":"https://steffandavies.github.io/theblackbox/p/library-review-pytube/cover_hub67ea65c1755bce418213aa668ca7f70_43556_120x120_fill_q75_box_smart1.jpg","permalink":"https://steffandavies.github.io/theblackbox/p/library-review-pytube/","title":"Library Review: pytube"}]